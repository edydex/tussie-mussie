<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tussie Mussie - Game Room</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    /* Inline additional card layout styles */
    .player-cards-container {
      position: relative;
      min-height: 230px;
      padding: 1rem;
      background-color: #f9f9f9;
      border-radius: 8px;
      margin-bottom: 1.5rem;
    }

    .player-cards {
      display: flex;
      justify-content: center;
      gap: 1rem;
      position: relative;
    }

    .card.keepsake-card {
      position: relative;
      top: 30px; /* Shift keepsakes down */
    }

    .keepsakes-area {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 75px;
      background-color: rgba(0, 0, 0, 0.03);
      border-radius: 0 0 8px 8px;
      z-index: 0;
    }

    .card-label {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      background-color: #f0f0f0;
      padding: 2px 6px;
      border-radius: 10px;
      border: 1px solid #ddd;
      white-space: nowrap;
    }

    .opponent-cards-container {
      position: relative;
      min-height: 180px;
      padding: 1rem;
      background-color: #f9f9f9;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .opponent-cards {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      position: relative;
    }

    .opponent-card.keepsake-card {
      top: 20px; /* Smaller shift for opponent cards */
    }

    .opponent .keepsakes-area {
      height: 55px; /* Smaller area for opponent keepsakes */
    }
    
    /* Turn Timer Styles */
    .turn-timer {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      transition: all 0.3s ease;
      opacity: 0;
      transform: translateY(-10px);
    }

    .turn-timer.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .turn-timer.urgent {
      background-color: rgba(255, 235, 235, 0.95);
    }

    .timer-icon {
      font-size: 1.5rem;
    }

    .timer-text {
      display: flex;
      flex-direction: column;
    }

    .timer-label {
      font-size: 0.8rem;
      color: #666;
    }

    #timerValue {
      font-weight: bold;
      font-size: 1.2rem;
    }

    /* Player score display */
    .player-score-display {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-weight: 600;
      display: none;
    }

    /* Round Information Styles */
    .round-info {
      background-color: #e8f5e9;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.2rem;
      border-left: 4px solid #4caf50;
    }
    
    /* Round Transition Overlay */
    .round-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .transition-content {
      background-color: white;
      padding: 2rem;
      border-radius: 8px;
      text-align: center;
      max-width: 90%;
      width: 500px;
    }
    
    .transition-content h2 {
      margin-bottom: 1rem;
      color: var(--primary-color);
    }
    
    .player-scores {
      margin: 1.5rem 0;
    }
    
    .transition-player-score {
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    
    .continue-button {
      display: inline-block;
      background-color: var(--primary-color);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 1rem;
      transition: background-color 0.2s;
    }
    
    .continue-button:hover {
      background-color: var(--secondary-color);
    }
    
    /* Player scores display */
    .player-score-display {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-weight: 600;
      display: none;
      background-color: #f5f5f5;
      padding: 0.5rem;
      border-radius: 4px;
    }
    
    /* Opponent scores */
    .opponent-scores {
      margin-bottom: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }
    
    .opponent-round-score, .opponent-total-score {
      color: var(--primary-color);
      font-weight: 600;
    }
    
    /* Results display */
    .round-scores {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
      justify-content: center;
    }
    
    .round-score {
      background-color: #f5f5f5;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .results-explanation {
      margin-bottom: 1.5rem;
      font-style: italic;
      color: #666;
    }

    /* Card ability highlight styles */
    .card.has-ability {
      box-shadow: 0 0 10px 3px gold;
      animation: ability-pulse 1.5s infinite;
      cursor: pointer;
      position: relative;
      z-index: 5;
    }

    .card.has-ability:after {
      content: "⚡";
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: gold;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      z-index: 6;
    }

    @keyframes ability-pulse {
      0% {
        box-shadow: 0 0 10px 3px rgba(255, 215, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.9);
      }
      100% {
        box-shadow: 0 0 10px 3px rgba(255, 215, 0, 0.6);
      }
    }
    
    /* Ability instructions */
    .ability-instructions {
      background-color: #fff9c4;
      border: 2px dashed #ffd600;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 1rem;
      text-align: center;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Tussie Mussie</h1>
      <div class="room-info">
        <div>Room Code: <span id="roomCodeDisplay"><%= roomCode %></span></div>
        <button id="copyRoomLink" class="btn small-btn">Copy Room Link</button>
      </div>
    </header>
    
    <!-- Turn Timer -->
    <div id="turnTimer" class="turn-timer">
      <div class="timer-icon">⏱️</div>
      <div class="timer-text">
        <div class="timer-label">Time remaining:</div>
        <div id="timerValue">30s</div>
      </div>
    </div>
    
    <main id="gamePage">
      <!-- Waiting Area (Lobby) -->
      <div id="waitingArea">
        <h2>Game Lobby</h2>
        <div class="lobby-container">
          <div class="players-section">
            <h3>Players</h3>
            <div id="playersList" class="players-list"></div>
          </div>
          
          <div class="lobby-controls">
            <button id="startGameBtn" class="btn primary-btn" disabled>Start Game</button>
            <p class="lobby-help">At least 2 players needed to start</p>
          </div>
        </div>
      </div>
      
      <!-- Game Area -->
      <div id="gameArea" style="display: none;">
        <div id="gameStatus" class="game-status"></div>
        
        <div class="game-container">
          <!-- Active Cards Area -->
          <div class="game-section">
            <h3>Active Cards</h3>
            <div id="activeCardsArea" class="active-cards-area"></div>
          </div>
          
          <!-- Player's Cards -->
          <div class="game-section">
            <h3>Your Cards</h3>
            <div id="playerScoreDisplay" class="player-score-display"></div>
            <div class="player-cards-container">
              <div class="keepsakes-area"></div>
              <div id="playerCards" class="player-cards"></div>
            </div>
          </div>
          
          <!-- Opponents' Cards -->
          <div class="game-section">
            <h3>Opponents</h3>
            <div id="opponentsArea" class="opponents-area"></div>
          </div>
          
          <!-- Scoring Area -->
          <div id="scoringArea" class="game-section scoring-section" style="display: none;">
            <h3>Scoring Phase</h3>
            <div id="abilityCards" class="ability-cards"></div>
            <button id="doneScoring" class="btn primary-btn">Done Scoring</button>
          </div>
          
          <!-- New Game Button (hidden initially) -->
          <button id="newGameBtn" class="btn primary-btn" style="display: none;">New Game</button>
        </div>
      </div>
    </main>
  </div>
  
  <script>
    // Simplified room joining mechanism - initialize socket first
    const socket = io();
    
    // Variables for room and player
    const roomCode = '<%= roomCode %>';
    const nickname = '<%= nickname %>';
    let currentPlayerId = '';
    let currentRoomCode = roomCode;
    let pinkLarkspurAbilityInProgress = false;
    let snapdragonAbilityInProgress = false;
    let snapdragonMovesUsed = 0;  // Track how many Snapdragon moves have been used
    let marigoldAbilityInProgress = false;
    let cardPositions = new Map(); // Store card positions for consistent rendering
    
    // DOM Elements
    const playersList = document.getElementById('playersList');
    const startGameBtn = document.getElementById('startGameBtn');
    const waitingArea = document.getElementById('waitingArea');
    const gameArea = document.getElementById('gameArea');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const activeCardsArea = document.getElementById('activeCardsArea');
    const playerCards = document.getElementById('playerCards');
    const opponentsArea = document.getElementById('opponentsArea');
    const gameStatus = document.getElementById('gameStatus');
    const scoringArea = document.getElementById('scoringArea');
    const doneScoring = document.getElementById('doneScoring');
    const newGameBtn = document.getElementById('newGameBtn');
    
    // Copy room link functionality
    document.getElementById('copyRoomLink').addEventListener('click', () => {
      const link = `${window.location.origin}/?join=${roomCode}`;
      navigator.clipboard.writeText(link)
        .then(() => {
          alert('Room link copied to clipboard! When others open this link, they will be prompted to enter a nickname.');
        })
        .catch(err => {
          console.error('Could not copy link: ', err);
        });
    });
    
    // Socket event handlers
    socket.on('connect', () => {
      console.log('Socket connected with ID:', socket.id);
      
      // Auto-join room if nickname is provided
      if (nickname) {
        console.log('Auto-joining room with nickname:', nickname);
        socket.emit('joinRoom', { roomCode, nickname });
      }
    });
    
    socket.on('updatePlayers', ({ players, canStart }) => {
      console.log('Received updatePlayers event. Players:', players);
      updatePlayersList(players);
      
      if (startGameBtn) {
        startGameBtn.disabled = !canStart;
      }
    });
    
    socket.on('gameStarted', () => {
      console.log('Game has started!');
      waitingArea.style.display = 'none';
      gameArea.style.display = 'block';
    });
    
    socket.on('updateGameState', (gameState) => {
      console.log('Received game state:', gameState);
      updateGameUI(gameState);
    });
    
    socket.on('gameReset', () => {
      console.log('Received gameReset event from server');
      resetGame();
    });
    
    socket.on('error', (message) => {
      console.error('Socket error:', message);
      alert(message);
    });
    
    // Game control event handlers
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        console.log('Starting game...');
        socket.emit('startGame', { roomCode });
      });
    }
    
    if (doneScoring) {
      doneScoring.addEventListener('click', () => {
        socket.emit('doneScoring', { roomCode });
        doneScoring.disabled = true;
      });
    }
    
    if (newGameBtn) {
      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked, sending request to server');
        socket.emit('newGame', { roomCode });
        
        // Disable the button temporarily to prevent multiple clicks
        newGameBtn.disabled = true;
        newGameBtn.textContent = 'Starting New Game...';
        
        // Re-enable after a delay
        setTimeout(() => {
          newGameBtn.disabled = false;
          newGameBtn.textContent = 'New Game';
          newGameBtn.style.display = 'none';
        }, 1000);
      });
    }
    
    // Helper Functions
    function updatePlayersList(players) {
      if (!playersList) return;
      
      console.log('Updating players list with:', players);
      playersList.innerHTML = '';
      
      players.forEach(player => {
        const playerItem = document.createElement('div');
        playerItem.classList.add('player-item');
        
        if (player.id === socket.id) {
          playerItem.classList.add('current-player');
          currentPlayerId = player.id;
        }
        
        playerItem.textContent = player.nickname;
        playersList.appendChild(playerItem);
      });
    }
    
    function updateGameUI(gameState) {
      // First, determine if we are the current player
      const isCurrentPlayer = gameState.currentPlayerId === currentPlayerId;
      const isReceivingPlayer = gameState.receivingPlayerId === currentPlayerId;
      
      // Update round information if available
      updateRoundInfo(gameState);
      
      // Update game status message
      updateGameStatus(gameState, isCurrentPlayer, isReceivingPlayer);
      
      // Handle turn timer
      if (gameState.phase === 'offering' && isCurrentPlayer) {
        startTurnTimer();
      } else if (gameState.phase === 'selection' && isReceivingPlayer) {
        startTurnTimer();
      } else if (gameState.phase !== 'offering' && gameState.phase !== 'selection') {
        clearTurnTimer();
      }
      
      // Set game phase attribute for CSS targeting
      if (gameArea) {
        gameArea.setAttribute('data-phase', gameState.phase);
      }
      
      // Update active cards area
      updateActiveCards(gameState.activeCards, gameState.phase, isCurrentPlayer, isReceivingPlayer);
      
      // Find current player data
      const currentPlayerData = gameState.players.find(p => p.id === currentPlayerId);
      
      // Update player's cards
      if (currentPlayerData) {
        updatePlayerCards(currentPlayerData);
      }
      
      // Update opponents' cards
      updateOpponentsCards(gameState.players);
      
      // Show/hide scoring UI
      if (gameState.phase === 'scoring') {
        showScoringUI(currentPlayerData, gameState);
      } else {
        hideScoringUI();
      }
      
      // Show game over UI if game is over
      if (gameState.phase === 'gameOver') {
        showGameOverUI(gameState.players);
      }
    }
    
    // Update round information display
    function updateRoundInfo(gameState) {
      // Create or update round info display if it doesn't exist
      let roundInfoElement = document.getElementById('roundInfo');
      if (!roundInfoElement) {
        roundInfoElement = document.createElement('div');
        roundInfoElement.id = 'roundInfo';
        roundInfoElement.classList.add('round-info');
        
        // Insert after game status
        const gameStatus = document.getElementById('gameStatus');
        if (gameStatus && gameStatus.parentNode) {
          gameStatus.parentNode.insertBefore(roundInfoElement, gameStatus.nextSibling);
        }
      }
      
      if (gameState.gameRound) {
        roundInfoElement.innerHTML = `<strong>Round ${gameState.gameRound} of 3</strong>`;
        roundInfoElement.style.display = 'block';
      } else {
        roundInfoElement.style.display = 'none';
      }
    }
    
    function updateGameStatus(gameState, isCurrentPlayer, isReceivingPlayer) {
      if (!gameStatus) return;
      
      let statusText = '';
      
      switch (gameState.phase) {
        case 'offering':
          if (isCurrentPlayer) {
            statusText = 'Your turn! Choose a card to hide (flip face-down).';
          } else {
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
            statusText = `${currentPlayer?.nickname || 'Current player'} is choosing a card to hide...`;
          }
          break;
          
        case 'selection':
          if (isReceivingPlayer) {
            statusText = 'Choose which card to take into your bouquet.';
          } else {
            const receivingPlayer = gameState.players.find(p => p.id === gameState.receivingPlayerId);
            statusText = `${receivingPlayer?.nickname || 'Next player'} is choosing a card...`;
          }
          break;
          
        case 'scoring':
          statusText = 'Scoring phase! Use your card abilities before final scoring.';
          break;
          
        case 'gameOver':
          statusText = 'Game over! Final scores are shown.';
          break;
      }
      
      gameStatus.textContent = statusText;
    }
    
    function updateActiveCards(activeCards, phase, isCurrentPlayer, isReceivingPlayer) {
      if (!activeCardsArea) return;
      
      // Find the parent game-section that contains the active cards area
      const activeCardsSection = activeCardsArea.closest('.game-section');
      
      // Hide the entire section during scoring or game over phases
      if (activeCardsSection) {
        if (phase === 'scoring' || phase === 'gameOver') {
          activeCardsSection.style.display = 'none';
          return; // Exit early, no need to update content for a hidden section
        } else {
          activeCardsSection.style.display = 'block';
        }
      }
      
      console.log('Updating active cards:', activeCards);
      activeCardsArea.innerHTML = '';
      
      if (!activeCards || activeCards.length === 0) {
        console.log('No active cards to display');
        return;
      }
      
      // Add a message for receiving player during offering phase
      if (phase === 'offering' && isReceivingPlayer) {
        const waitingMessage = document.createElement('div');
        waitingMessage.classList.add('waiting-message');
        waitingMessage.textContent = 'Waiting for other player to choose a card to hide...';
        activeCardsArea.appendChild(waitingMessage);
        return;
      }
      
      // Create and add card elements
      activeCards.forEach((card, index) => {
        console.log('Creating card element for active card:', card);
        
        // During offering phase, cards are only visible to current player
        const shouldShowCard = !(phase === 'offering' && !isCurrentPlayer);
        
        const cardElement = createCardElement(card, false, shouldShowCard);
        
        // Add click handler based on game phase
        if (phase === 'offering' && isCurrentPlayer) {
          // Only face-up cards can be flipped in the offering phase
          if (card.faceUp) {
            cardElement.classList.add('selectable');
            cardElement.addEventListener('click', () => {
              console.log('Hiding card at index', index);
              socket.emit('flipCard', { roomCode, cardIndex: index });
            });
          }
        } else if (phase === 'selection' && isReceivingPlayer) {
          // Both face-up and face-down cards can be selected
          cardElement.classList.add('selectable');
          cardElement.addEventListener('click', () => {
            console.log('Selecting card at index', index);
            socket.emit('selectCard', { roomCode, cardIndex: index });
          });
        }
        
        activeCardsArea.appendChild(cardElement);
      });
    }
    
    function updatePlayerCards(playerData) {
      if (!playerCards) return;
      
      // Save current card positions before clearing the container
      const allCurrentCards = document.querySelectorAll('.player-card');
      allCurrentCards.forEach((cardElement) => {
        if (cardElement.dataset.cardId) {
          const rect = cardElement.getBoundingClientRect();
          cardPositions.set(cardElement.dataset.cardId, {
            index: Array.from(playerCards.children).indexOf(cardElement),
            left: rect.left,
            top: rect.top,
            isKeepsake: cardElement.classList.contains('keepsake-card')
          });
        }
      });
      
      // Clear current cards
      playerCards.innerHTML = '';
      
      // Sort cards based on previous positions if available
      const sortedCards = [...playerData.cards].sort((a, b) => {
        const posA = cardPositions.has(a.id) ? cardPositions.get(a.id).index : 999;
        const posB = cardPositions.has(b.id) ? cardPositions.get(b.id).index : 999;
        return posA - posB;
      });
      
      // Create card elements
      sortedCards.forEach((card) => {
        const cardElement = createCardElement(card);
        cardElement.classList.add('player-card');
        cardElement.dataset.location = card.location;
        
        // Add a class for keepsake cards to apply the shifted positioning
        if (card.location === 'keepsakes') {
          cardElement.classList.add('keepsake-card');
          
          // Add a small label to indicate keepsake
          const label = document.createElement('div');
          label.className = 'card-label';
          label.textContent = 'Keepsake';
          cardElement.appendChild(label);
        } else {
          // Add bouquet label for scoring phase
          const label = document.createElement('div');
          label.className = 'card-label';
          label.textContent = 'Bouquet';
          cardElement.appendChild(label);
        }
        
        // Highlight cards with abilities during scoring phase
        if (hasAbility(card.id) && gameArea.getAttribute('data-phase') === 'scoring' && !card.abilityUsed) {
          cardElement.classList.add('has-ability');
          
          // Add click handler for ability activation
          cardElement.addEventListener('click', () => {
            handleCardAbility(card.id, playerData);
          });
        }
        
        // Apply smooth animation for cards that move between bouquet and keepsakes
        const prevPos = cardPositions.get(card.id);
        if (prevPos) {
          const isMovedCard = (prevPos.isKeepsake && card.location === 'bouquet') || 
                             (!prevPos.isKeepsake && card.location === 'keepsakes');
          
          if (isMovedCard) {
            cardElement.style.transition = 'transform 0.5s ease-in-out, opacity 0.3s';
            cardElement.style.opacity = '0';
            
            // Enable animation after a short delay to ensure positions are calculated
            setTimeout(() => {
              cardElement.style.opacity = '1';
            }, 50);
          }
        }
        
        playerCards.appendChild(cardElement);
      });
      
      // Update player score display
      const playerScoreDisplay = document.getElementById('playerScoreDisplay');
      if (playerScoreDisplay && playerData.score !== undefined) {
        playerScoreDisplay.style.display = 'block';
        playerScoreDisplay.innerHTML = `
          <div>Round Score: ${playerData.score || 0}</div>
          <div>Total Score: ${playerData.totalScore || 0}</div>
        `;
      }
    }
    
    function updateOpponentsCards(players) {
      if (!opponentsArea) return;
      
      // Clear current opponents
      opponentsArea.innerHTML = '';
      
      // Add each opponent
      players.forEach(player => {
        if (player.id === currentPlayerId) return; // Skip current player
        
        const opponentElement = document.createElement('div');
        opponentElement.classList.add('opponent');
        
        // Add opponent name
        const nameElement = document.createElement('div');
        nameElement.classList.add('opponent-name');
        nameElement.textContent = player.nickname;
        opponentElement.appendChild(nameElement);
        
        // Add opponent scores
        if (player.score !== undefined) {
          const scoreContainer = document.createElement('div');
          scoreContainer.classList.add('opponent-scores');
          
          const roundScoreElement = document.createElement('div');
          roundScoreElement.classList.add('opponent-round-score');
          roundScoreElement.textContent = `Round Score: ${player.score}`;
          scoreContainer.appendChild(roundScoreElement);
          
          const totalScoreElement = document.createElement('div');
          totalScoreElement.classList.add('opponent-total-score');
          totalScoreElement.textContent = `Total Score: ${player.totalScore || 0}`;
          scoreContainer.appendChild(totalScoreElement);
          
          opponentElement.appendChild(scoreContainer);
        }
        
        // Add opponent's cards in a single container
        const cardsContainer = document.createElement('div');
        cardsContainer.classList.add('opponent-cards-container');
        
        // Add keepsakes background area
        const keepsakesArea = document.createElement('div');
        keepsakesArea.classList.add('keepsakes-area');
        cardsContainer.appendChild(keepsakesArea);
        
        const cardsElement = document.createElement('div');
        cardsElement.classList.add('opponent-cards');
        
        // Sort cards to maintain order (if we had a way to track original order)
        const sortedCards = [...player.cards];
        
        sortedCards.forEach(card => {
          const cardElement = createCardElement(card, true);
          if (card.location === 'keepsakes') {
            cardElement.classList.add('keepsake-card');
          }
          cardsElement.appendChild(cardElement);
        });
        
        cardsContainer.appendChild(cardsElement);
        opponentElement.appendChild(cardsContainer);
        opponentsArea.appendChild(opponentElement);
      });
    }
    
    function showScoringUI(playerData, gameState) {
      if (!scoringArea || !doneScoring) return;
      
      // Mark the game area with current phase for CSS targeting
      gameArea.setAttribute('data-phase', 'scoring');
      
      scoringArea.style.display = 'block';
      
      // Check if the player has an unused marigold ability card
      const allCards = [...(playerData.bouquet || []), ...(playerData.keepsakes || [])];
      const hasUnusedMarigold = allCards.some(card => card.id === 'marigold' && !card.abilityUsed);
      
      // Disable the Done Scoring button if an unused marigold exists
      doneScoring.disabled = hasUnusedMarigold || playerData?.doneScoring;
      
      // If there is an unused marigold, display a warning message
      let warningElement = document.getElementById('marigoldWarning');
      if (hasUnusedMarigold) {
        if (!warningElement) {
          warningElement = document.createElement('div');
          warningElement.id = 'marigoldWarning';
          warningElement.classList.add('ability-warning');
          warningElement.innerHTML = '⚠️ You must use Marigold\'s ability (discard one card) before finishing scoring.';
          scoringArea.insertBefore(warningElement, doneScoring);
        }
      } else if (warningElement) {
        warningElement.remove();
      }
      
      // Add card ability instructions instead of duplicating the cards
      const abilityCardsContainer = document.getElementById('abilityCards');
      if (abilityCardsContainer) {
        abilityCardsContainer.innerHTML = '';
        
        // Find cards with abilities
        const cardsWithAbilities = [
          ...(playerData.bouquet || []).filter(card => hasAbility(card.id) && !card.abilityUsed),
          ...(playerData.keepsakes || []).filter(card => hasAbility(card.id) && !card.abilityUsed)
        ];
        
        if (cardsWithAbilities.length > 0) {
          const instructionsElement = document.createElement('div');
          instructionsElement.classList.add('ability-instructions');
          
          const abilityNames = cardsWithAbilities.map(card => card.name).join(', ');
          instructionsElement.innerHTML = `
            <div>⚡ <strong>Card Abilities Available</strong> ⚡</div>
            <div>Click on highlighted cards in your collection to use their abilities.</div>
            <div>Available: ${abilityNames}</div>
          `;
          
          abilityCardsContainer.appendChild(instructionsElement);
        }
      }
    }
    
    function hideScoringUI() {
      if (!scoringArea) return;
      
      scoringArea.style.display = 'none';
      
      // Remove scoring phase marker
      if (gameArea) {
        gameArea.removeAttribute('data-phase');
      }
      
      // Reset all ability flags and card positions
      pinkLarkspurAbilityInProgress = false;
      snapdragonAbilityInProgress = false;
      snapdragonMovesUsed = 0;  
      marigoldAbilityInProgress = false;
      cardPositions.clear();
    }
    
    function showGameOverUI(players) {
      if (!gameStatus) return;
      
      // Sort players by totalScore (highest first)
      const sortedPlayers = [...players].sort((a, b) => b.totalScore - a.totalScore);
      
      const resultsContainer = document.createElement('div');
      resultsContainer.classList.add('results-container');
      
      const resultsHeader = document.createElement('h2');
      resultsHeader.textContent = 'Final Scores';
      resultsContainer.appendChild(resultsHeader);
      
      // Add explanation about accumulated scores
      const explanation = document.createElement('p');
      explanation.classList.add('results-explanation');
      explanation.textContent = 'Scores accumulated over 3 rounds';
      resultsContainer.appendChild(explanation);
      
      sortedPlayers.forEach((player, index) => {
        const playerResult = document.createElement('div');
        playerResult.classList.add('player-result');
        
        if (index === 0) {
          playerResult.classList.add('winner');
        }
        
        if (player.id === currentPlayerId) {
          playerResult.classList.add('current-player');
        }
        
        // Create round scores display
        let roundScoresHtml = '';
        if (player.roundScores && player.roundScores.length > 0) {
          roundScoresHtml = '<div class="round-scores">';
          player.roundScores.forEach((score, idx) => {
            roundScoresHtml += `<span class="round-score">Round ${idx + 1}: ${score}</span>`;
          });
          roundScoresHtml += '</div>';
        }
        
        playerResult.innerHTML = `
          <div class="result-player-name">${player.nickname}</div>
          <div class="result-player-score">${player.totalScore} points</div>
          ${roundScoresHtml}
        `;
        
        resultsContainer.appendChild(playerResult);
      });
      
      // Clear existing results before adding new ones
      const existingResults = document.querySelector('.results-container');
      if (existingResults) {
        existingResults.remove();
      }
      
      if (newGameBtn) {
        newGameBtn.style.display = 'block';
      }
      
      // Add results to game area
      gameArea.appendChild(resultsContainer);
    }
    
    function resetGame() {
      console.log('Resetting game...');
      
      // Reset all ability flags and card positions
      pinkLarkspurAbilityInProgress = false;
      snapdragonAbilityInProgress = false;
      snapdragonMovesUsed = 0;  
      marigoldAbilityInProgress = false;
      cardPositions.clear();
      
      // Hide game over elements
      if (newGameBtn) {
        newGameBtn.style.display = 'none';
      }
      
      // Remove results container
      const existingResults = document.querySelector('.results-container');
      if (existingResults) {
        existingResults.remove();
      }
      
      // Clear player cards
      if (playerCards) {
        playerCards.innerHTML = '';
      }
      
      // Clear opponents area
      if (opponentsArea) {
        opponentsArea.innerHTML = '';
      }
      
      // Clear active cards
      if (activeCardsArea) {
        activeCardsArea.innerHTML = '';
      }
      
      // Clear turn timer
      clearTurnTimer();
      
      // For proper flow in the new game, show waiting area, hide game area
      if (waitingArea && gameArea) {
        waitingArea.style.display = 'block';
        gameArea.style.display = 'none';
      }
      
      // Reset game status
      if (gameStatus) {
        gameStatus.textContent = 'New game is ready to start!';
      }
      
      console.log('Game reset complete');
    }
    
    function createCardElement(card, isOpponent = false, isVisible = true) {
      if (!card) {
        console.error('Attempted to create card element with undefined card');
        return document.createElement('div'); // Return empty div to avoid errors
      }
      
      console.log('Creating card element for:', card, 'visible:', isVisible);
      const cardElement = document.createElement('div');
      cardElement.classList.add('card');
      cardElement.dataset.cardId = card.id;
      
      // Apply hidden state if card should not be visible
      if (!isVisible) {
        cardElement.classList.add('hidden-card');
        
        // Add mystery placeholder
        const mysteryContent = document.createElement('div');
        mysteryContent.classList.add('card-mystery');
        mysteryContent.innerHTML = '<span>?</span>';
        cardElement.appendChild(mysteryContent);
        return cardElement;
      }
      
      if (card.faceUp) {
        cardElement.classList.add('face-up');
        cardElement.classList.add(card.color);
        
        // Card content for face-up card
        const cardHeader = document.createElement('div');
        cardHeader.classList.add('card-header');
        
        const cardName = document.createElement('div');
        cardName.classList.add('card-name');
        cardName.textContent = card.name;
        cardHeader.appendChild(cardName);
        
        // Add hearts
        const cardHearts = document.createElement('div');
        cardHearts.classList.add('card-hearts');
        for (let i = 0; i < card.hearts; i++) {
          const heart = document.createElement('span');
          heart.textContent = '❤️';
          cardHearts.appendChild(heart);
        }
        cardHeader.appendChild(cardHearts);
        cardElement.appendChild(cardHeader);
        
        // Card effect text
        const cardEffect = document.createElement('div');
        cardEffect.classList.add('card-effect');
        cardEffect.textContent = card.effectText;
        cardElement.appendChild(cardEffect);
        
        // Card flavor text
        const cardFlavor = document.createElement('div');
        cardFlavor.classList.add('card-flavor');
        cardFlavor.textContent = card.flavorText;
        cardElement.appendChild(cardFlavor);
      } else {
        cardElement.classList.add('face-down');
        
        // Simple card back design
        const cardBack = document.createElement('div');
        cardBack.classList.add('card-back');
        cardBack.textContent = 'Tussie Mussie';
        cardElement.appendChild(cardBack);
      }
      
      // Make opponent cards smaller
      if (isOpponent) {
        cardElement.classList.add('opponent-card');
      }
      
      return cardElement;
    }
    
    function hasAbility(cardId) {
      return ['pink-larkspur', 'snapdragon', 'marigold'].includes(cardId);
    }
    
    function handleCardAbility(cardId, playerData) {
      // For simplicity, we'll implement only a basic UI for abilities
      switch (cardId) {
        case 'pink-larkspur':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || snapdragonAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Set flag to indicate ability is in progress
          pinkLarkspurAbilityInProgress = true;
          
          // First, draw two cards from the deck
          socket.emit('useCardAbility', {
            roomCode,
            cardId: 'pink-larkspur'
          });

          // Create a persistent function to handle both steps of the ability
          function handlePinkLarkspurResponse(result) {
            console.log("Pink larkspur response:", result);
            
            // Step 1: Process drawn cards
            if (result.ability === 'pink-larkspur-draw' && result.drawnCards) {
              showDrawnCardsSelection(result.drawnCards, (selectedDrawnCardIndex) => {
                // Save the selected card index for step 2
                const selectedCard = result.drawnCards[selectedDrawnCardIndex];
                console.log("Selected drawn card:", selectedCard);
                
                // After player selects a drawn card, prompt to select which card to replace
                showAbilityInstructions('Now select one of your cards to replace with the chosen card.');
                
                // Get all player cards and make them selectable
                const allPlayerCards = document.querySelectorAll('.player-card');
                allPlayerCards.forEach(cardElement => {
                  // Add visual indicators
                  cardElement.classList.add('selectable');
                  
                  // Add hover effect
                  cardElement.addEventListener('mouseenter', function() {
                    this.style.boxShadow = '0 0 10px 5px rgba(255, 0, 0, 0.5)';
                    this.style.opacity = '0.8';
                  });
                  
                  cardElement.addEventListener('mouseleave', function() {
                    this.style.boxShadow = '';
                    this.style.opacity = '1';
                  });
                  
                  // Add click handler for selection
                  cardElement.addEventListener('click', function cardClickHandler() {
                    // Remove event listeners from all cards
                    allPlayerCards.forEach(c => {
                      c.classList.remove('selectable');
                      c.style.boxShadow = '';
                      c.style.opacity = '1';
                      c.removeEventListener('mouseenter', arguments.callee);
                      c.removeEventListener('mouseleave', arguments.callee);
                      c.removeEventListener('click', cardClickHandler);
                    });
                    
                    const targetCardId = this.dataset.cardId;
                    console.log("Selected player card to replace:", targetCardId);
                    
                    // Visual feedback for the card being replaced
                    this.style.transition = 'all 0.3s ease';
                    this.style.opacity = '0';
                    this.style.transform = 'scale(0.8)';
                    
                    // Send the card replacement request
                    socket.emit('useCardAbility', {
                      roomCode,
                      cardId: 'pink-larkspur',
                      targetCardId: `${selectedDrawnCardIndex}|${targetCardId}`
                    });
                    
                    hideAbilityInstructions();
                  });
                });
              });
            } 
            // Step 2: Handle replacement confirmation
            else if (result.ability === 'pink-larkspur-replace') {
              console.log("Card replacement successful");
              // Clean up the event listener
              socket.off('cardAbilityResult', handlePinkLarkspurResponse);
              // Reset the ability flag
              pinkLarkspurAbilityInProgress = false;
            }
          }
          
          // Listen for both steps of the ability process
          socket.on('cardAbilityResult', handlePinkLarkspurResponse);
          break;
        
        case 'snapdragon':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Check if we've already used both Snapdragon moves
          if (snapdragonMovesUsed >= 2) {
            alert('You have already used Snapdragon\'s ability twice.');
            return;
          }
          
          // Set flag to indicate ability is in progress
          snapdragonAbilityInProgress = true;
          
          // Allow player to move up to 2 cards between bouquet and keepsakes
          const movesRemaining = 2 - snapdragonMovesUsed;
          alert(`Snapdragon: Click a card to move it between bouquet and keepsakes. (${movesRemaining} move${movesRemaining > 1 ? 's' : ''} remaining)`);
          
          // Add click handlers to all player cards
          const playerCards = document.querySelectorAll('.player-card');
          
          // Store current positions of all cards before movement
          playerCards.forEach((card, index) => {
            if (card.dataset.cardId) {
              const rect = card.getBoundingClientRect();
              cardPositions.set(card.dataset.cardId, {
                index: index,
                left: rect.left,
                top: rect.top,
                isKeepsake: card.classList.contains('keepsake-card')
              });
            }
          });
          
          playerCards.forEach(cardElement => {
            cardElement.classList.add('selectable');
            
            // Add hover effect to preview movement
            cardElement.addEventListener('mouseenter', () => {
              const isKeepsake = cardElement.classList.contains('keepsake-card');
              cardElement.style.transition = 'transform 0.2s ease';
              cardElement.style.transform = isKeepsake ? 'translateY(-30px)' : 'translateY(30px)';
            });
            
            cardElement.addEventListener('mouseleave', () => {
              cardElement.style.transition = 'transform 0.2s ease';
              cardElement.style.transform = '';
            });
            
            cardElement.addEventListener('click', () => {
              const targetCardId = cardElement.dataset.cardId;
              const isKeepsake = cardElement.classList.contains('keepsake-card');
              
              // Toggle the keepsake state for this card in position tracking
              if (cardPositions.has(targetCardId)) {
                const pos = cardPositions.get(targetCardId);
                pos.isKeepsake = !pos.isKeepsake;
              }
              
              // Animate the card movement immediately for visual feedback
              cardElement.style.transition = 'transform 0.5s ease, top 0.5s ease';
              
              if (isKeepsake) {
                // Move from keepsake to bouquet (move up)
                cardElement.style.transform = 'translateY(-30px)';
                setTimeout(() => {
                  cardElement.classList.remove('keepsake-card');
                }, 100);
              } else {
                // Move from bouquet to keepsake (move down)
                cardElement.style.transform = 'translateY(30px)';
                setTimeout(() => {
                  cardElement.classList.add('keepsake-card');
                }, 100);
              }
              
              // Send the move to server
              socket.emit('useCardAbility', {
                roomCode,
                cardId: 'snapdragon',
                targetCardId
              });
              
              // Increment the counter for Snapdragon moves
              snapdragonMovesUsed++;
              
              // Force a layout recalculation to make other cards update positions
              requestAnimationFrame(() => {
                // Remove selection state from all cards
                playerCards.forEach(c => {
                  c.classList.remove('selectable');
                  
                  // Remove hover event listeners
                  c.onmouseenter = null;
                  c.onmouseleave = null;
                });
              });
              
              // Reset the ability in progress flag to allow another use
              snapdragonAbilityInProgress = false;
              
              // If we've used both moves, show a message
              if (snapdragonMovesUsed >= 2) {
                alert('You have used both Snapdragon ability moves.');
              } else {
                // Show how many moves are left
                setTimeout(() => {
                  alert(`Snapdragon: You have ${2 - snapdragonMovesUsed} move remaining. Click on the Snapdragon card again to use it.`);
                }, 500);
              }
            }, { once: true });
          });
          break;
          
        case 'marigold':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || snapdragonAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Set flag to indicate ability is in progress
          marigoldAbilityInProgress = true;
          
          // Player must discard one card
          alert('Marigold: You must discard one of your other cards.');
          
          // Store current positions of all cards before discard
          const allCards = document.querySelectorAll('.player-card');
          allCards.forEach((card, index) => {
            if (card.dataset.cardId) {
              const rect = card.getBoundingClientRect();
              cardPositions.set(card.dataset.cardId, {
                index: index,
                left: rect.left,
                top: rect.top,
                isKeepsake: card.classList.contains('keepsake-card')
              });
            }
          });
          
          // Add click handlers to all player cards except Marigold
          const otherCards = document.querySelectorAll('.player-card:not([data-card-id="marigold"])');
          otherCards.forEach(cardElement => {
            cardElement.classList.add('selectable');
            
            // Add hover effect to preview discard
            cardElement.addEventListener('mouseenter', () => {
              cardElement.style.boxShadow = '0 0 10px 5px rgba(255, 0, 0, 0.5)';
              cardElement.style.opacity = '0.8';
              cardElement.style.transform = 'scale(0.95)';
            });
            
            cardElement.addEventListener('mouseleave', () => {
              cardElement.style.boxShadow = '';
              cardElement.style.opacity = '1';
              cardElement.style.transform = 'scale(1)';
            });
            
            cardElement.addEventListener('click', () => {
              const targetCardId = cardElement.dataset.cardId;
              
              // Visual effect for discard
              cardElement.style.transition = 'all 0.3s ease';
              cardElement.style.opacity = '0';
              cardElement.style.transform = 'scale(0.8)';
              
              // Send discard to server
              socket.emit('useCardAbility', {
                roomCode,
                cardId: 'marigold',
                targetCardId
              });
              
              // Remove selection state
              otherCards.forEach(c => {
                c.classList.remove('selectable');
                c.style.boxShadow = '';
                c.style.opacity = '1';
                c.style.transform = 'scale(1)';
                
                // Remove hover event listeners
                c.onmouseenter = null;
                c.onmouseleave = null;
              });
              
              // Reset the flag when ability is complete
              marigoldAbilityInProgress = false;
            }, { once: true });
          });
          break;
      }
    }
    
    // Helper function to show drawn cards and let player choose one
    function showDrawnCardsSelection(drawnCards, callback) {
      // Create a modal for card selection
      const modal = document.createElement('div');
      modal.classList.add('card-selection-modal');
      modal.innerHTML = `
        <div class="modal-content">
          <h3>Pink Larkspur Ability</h3>
          <p>Select one of these cards to add to your collection:</p>
          <div class="drawn-cards-container"></div>
        </div>
      `;
      
      // Style the modal
      const modalStyle = document.createElement('style');
      modalStyle.textContent = `
        .card-selection-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        }
        .modal-content {
          background-color: white;
          padding: 20px;
          border-radius: 8px;
          max-width: 80%;
          text-align: center;
        }
        .drawn-cards-container {
          display: flex;
          justify-content: center;
          gap: 20px;
          margin-top: 20px;
        }
        .ability-instructions {
          position: fixed;
          top: 80px;
          left: 50%;
          transform: translateX(-50%);
          background-color: #fffde7;
          border: 1px solid #ffc107;
          padding: 10px 20px;
          border-radius: 4px;
          z-index: 1000;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
      `;
      
      document.head.appendChild(modalStyle);
      document.body.appendChild(modal);
      
      // Add the drawn cards to the modal
      const drawnCardsContainer = modal.querySelector('.drawn-cards-container');
      drawnCards.forEach((card, index) => {
        const cardElement = createCardElement(card);
        cardElement.classList.add('selectable');
        
        cardElement.addEventListener('click', () => {
          // Call the callback with the selected card index
          document.body.removeChild(modal);
          callback(index);
        });
        
        drawnCardsContainer.appendChild(cardElement);
      });
    }
    
    // Helper functions for ability instructions
    function showAbilityInstructions(text) {
      // Remove any existing instructions
      hideAbilityInstructions();
      
      // Create new instructions
      const instructions = document.createElement('div');
      instructions.id = 'abilityInstructions';
      instructions.classList.add('ability-instructions');
      instructions.textContent = text;
      
      document.body.appendChild(instructions);
    }
    
    function hideAbilityInstructions() {
      const instructions = document.getElementById('abilityInstructions');
      if (instructions) {
        instructions.parentNode.removeChild(instructions);
      }
    }
    
    // Turn timer functionality
    let timerInterval = null;
    const turnTimer = document.getElementById('turnTimer');
    const timerValue = document.getElementById('timerValue');
    const TURN_TIME = 30; // seconds
    let timeRemaining = TURN_TIME;
    
    function startTurnTimer() {
      // Clear any existing timer
      clearTurnTimer();
      
      // Reset time
      timeRemaining = TURN_TIME;
      updateTimerDisplay();
      
      // Show timer
      turnTimer.classList.add('visible');
      turnTimer.classList.remove('urgent');
      
      // Start countdown
      timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();
        
        // Make timer urgent when less than 10 seconds remain
        if (timeRemaining <= 10) {
          turnTimer.classList.add('urgent');
        }
        
        // Stop at 0
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
        }
      }, 1000);
    }
    
    function clearTurnTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      turnTimer.classList.remove('visible');
    }
    
    function updateTimerDisplay() {
      timerValue.textContent = `${timeRemaining}s`;
    }

    // Show round transition info
    function showRoundTransition(gameRound) {
      // Create a modal for round transition
      let transitionOverlay = document.getElementById('roundTransition');
      if (!transitionOverlay) {
        transitionOverlay = document.createElement('div');
        transitionOverlay.id = 'roundTransition';
        transitionOverlay.classList.add('round-transition');
        document.body.appendChild(transitionOverlay);
      }
      
      transitionOverlay.innerHTML = `
        <div class="transition-content">
          <h2>Round ${gameRound - 1} Complete!</h2>
          <p>Moving to Round ${gameRound} of 3</p>
          <div class="continue-button">Continue to Next Round</div>
        </div>
      `;
      
      // Show the overlay
      transitionOverlay.style.display = 'flex';
      
      // Add click handler to continue button
      document.querySelector('#roundTransition .continue-button').addEventListener('click', () => {
        transitionOverlay.style.display = 'none';
      });
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        transitionOverlay.style.display = 'none';
      }, 5000);
    }
    
    // Listen for round transitions
    socket.on('roundComplete', ({ gameRound }) => {
      console.log('Round complete, moving to round:', gameRound);
      showRoundTransition(gameRound);
    });
  </script>
</body>
</html>