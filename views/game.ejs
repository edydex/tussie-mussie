<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tussie Mussie - Game Room</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    /* Inline additional card layout styles */
    .player-cards-container {
      position: relative;
      min-height: 230px;
      padding: 1rem;
      background-color: #f9f9f9;
      border-radius: 8px;
      margin-bottom: 1.5rem;
    }

    .player-cards {
      display: flex;
      justify-content: center;
      gap: 1rem;
      position: relative;
    }

    .card.keepsake-card {
      position: relative;
      top: 30px; /* Shift keepsakes down */
    }

    .keepsakes-area {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 75px;
      background-color: rgba(0, 0, 0, 0.03);
      border-radius: 0 0 8px 8px;
      z-index: 0;
    }

    .card-label {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      background-color: #f0f0f0;
      padding: 2px 6px;
      border-radius: 10px;
      border: 1px solid #ddd;
      white-space: nowrap;
    }

    .opponent-cards-container {
      position: relative;
      min-height: 180px;
      padding: 1rem;
      background-color: #f9f9f9;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .opponent-cards {
      display: flex;
      justify-content: center;
      gap: 0.75rem;
      position: relative;
    }

    .opponent-card.keepsake-card {
      top: 20px; /* Smaller shift for opponent cards */
    }

    .opponent .keepsakes-area {
      height: 55px; /* Smaller area for opponent keepsakes */
    }
    
    /* Mobile responsive overrides for card layout */
    @media (max-width: 768px) {
      .player-cards-container {
        padding: 0.5rem;
        min-height: 180px; /* Space for keepsake offset */
        margin-bottom: 0.5rem;
      }
      
      .opponent-cards-container {
        padding: 0.5rem;
        min-height: 150px; /* Space for keepsake offset */
        margin-bottom: 0.5rem;
      }
      
      .player-cards,
      .opponent-cards {
        gap: 0.35rem;
        padding: 0.25rem;
        flex-wrap: nowrap;
        overflow-x: visible; /* No scroll within card area */
        -webkit-overflow-scrolling: touch;
      }
      
      /* KEEP keepsake offset - it's crucial game logic! */
      .card.keepsake-card {
        top: 25px; /* Keep the offset */
      }
      
      .opponent-card.keepsake-card {
        top: 18px; /* Keep the offset for opponents */
      }
      
      /* Hide the gray background area - labels are enough */
      .keepsakes-area {
        display: none;
      }
      
      .opponent .keepsakes-area {
        display: none;
      }
      
      .card-label {
        font-size: 0.6rem;
        padding: 1px 4px;
        top: -8px;
      }
    }
    
    @media (max-width: 400px) {
      .player-cards,
      .opponent-cards {
        gap: 0.3rem;
      }
    }
    
    /* Turn Timer Styles */
    .turn-timer {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      transition: all 0.3s ease;
      opacity: 0;
      transform: translateY(-10px);
    }

    .turn-timer.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .turn-timer.urgent {
      background-color: rgba(255, 235, 235, 0.95);
    }

    .timer-icon {
      font-size: 1.5rem;
    }

    .timer-text {
      display: flex;
      flex-direction: column;
    }

    .timer-label {
      font-size: 0.8rem;
      color: #666;
    }

    #timerValue {
      font-weight: bold;
      font-size: 1.2rem;
    }

    /* Player score display */
    .player-score-display {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-weight: 600;
      display: none;
    }

    /* Round Information Styles */
    .round-info {
      background-color: #e8f5e9;
      border-radius: 8px;
      padding: 0.5rem 1rem;
      text-align: center;
      margin-bottom: 1rem;
      font-size: 1.2rem;
      border-left: 4px solid #4caf50;
    }
    
    /* Round Transition Overlay */
    .round-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .transition-content {
      background-color: white;
      padding: 2rem;
      border-radius: 8px;
      text-align: center;
      max-width: 90%;
      width: 500px;
    }
    
    .transition-content h2 {
      margin-bottom: 1rem;
      color: var(--primary-color);
    }
    
    .player-scores {
      margin: 1.5rem 0;
    }
    
    .transition-player-score {
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }
    
    .continue-button {
      display: inline-block;
      background-color: var(--primary-color);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 1rem;
      transition: background-color 0.2s;
    }
    
    .continue-button:hover {
      background-color: var(--secondary-color);
    }
    
    .waiting-message {
      display: inline-block;
      background-color: #f5f5f5;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      margin-top: 1rem;
      color: #666;
      font-style: italic;
    }

    /* Player scores display */
    .player-score-display {
      margin-bottom: 1rem;
      color: var(--primary-color);
      font-weight: 600;
      display: none;
      background-color: #f5f5f5;
      padding: 0.5rem;
      border-radius: 4px;
    }
    
    /* Opponent scores */
    .opponent-scores {
      margin-bottom: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
    }
    
    .opponent-round-score, .opponent-total-score {
      color: var(--primary-color);
      font-weight: 600;
    }
    
    /* Results display */
    .round-scores {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
      justify-content: center;
    }
    
    .round-score {
      background-color: #f5f5f5;
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .results-explanation {
      margin-bottom: 1.5rem;
      font-style: italic;
      color: #666;
    }

    /* Card ability highlight styles */
    .card.has-ability {
      box-shadow: 0 0 10px 3px gold;
      animation: ability-pulse 1.5s infinite;
      cursor: pointer;
      position: relative;
      z-index: 5;
    }

    .card.has-ability:after {
      content: "‚ö°";
      position: absolute;
      top: -10px;
      right: -10px;
      background-color: gold;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      z-index: 6;
    }

    @keyframes ability-pulse {
      0% {
        box-shadow: 0 0 10px 3px rgba(255, 215, 0, 0.6);
      }
      50% {
        box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.9);
      }
      100% {
        box-shadow: 0 0 10px 3px rgba(255, 215, 0, 0.6);
      }
    }
    
    /* Ability instructions */
    .ability-instructions {
      background-color: #fff9c4;
      border: 2px dashed #ffd600;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 1rem;
      text-align: center;
      font-weight: 500;
    }

    /* Host indicator styles */
    .host-indicator {
      background-color: #ffd700;
      color: #333;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.7rem;
      margin-left: 6px;
      font-weight: bold;
    }
    
    .player-item.host {
      background-color: #fffde7;
      border-left: 3px solid #ffd700;
    }
    
    /* Card Preview Modal Styles */
    .card-preview-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-in;
    }
    
    .card-preview-modal.visible {
      display: flex;
    }
    
    .card-preview-content {
      background: white;
      padding: 1rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card-preview-image {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
      border-radius: 8px;
    }
    
    .card-preview-info {
      margin-top: 1rem;
      text-align: center;
    }
    
    .card-preview-name {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }
    
    .card-preview-close {
      margin-top: 1rem;
      padding: 0.5rem 1rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    /* Card long-press hint - removed eye icon, keep functionality */
    .card.can-preview {
      cursor: pointer;
      position: relative;
    }
    
    .card.can-preview:active {
      transform: scale(0.98);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Tussie Mussie</h1>
      <div class="room-info">
        <div>Room Code: <span id="roomCodeDisplay"><%= roomCode %></span></div>
        <button id="copyRoomLink" class="btn small-btn">Copy Room Link</button>
      </div>
    </header>
    
    <!-- Turn Timer -->
    <div id="turnTimer" class="turn-timer">
      <div class="timer-icon">‚è±Ô∏è</div>
      <div class="timer-text">
        <div class="timer-label">Time remaining:</div>
        <div id="timerValue">30s</div>
      </div>
    </div>
    
    <main id="gamePage">
      <!-- Waiting Area (Lobby) -->
      <div id="waitingArea">
        <h2>Game Lobby</h2>
        <div class="lobby-container">
          <div class="players-section">
            <h3>Players</h3>
            <div id="playersList" class="players-list"></div>
          </div>
          
          <div class="lobby-controls">
            <button id="startGameBtn" class="btn primary-btn" disabled>Start Game</button>
            <p class="lobby-help">At least 2 players needed to start</p>
          </div>
        </div>
      </div>
      
      <!-- Game Area -->
      <div id="gameArea" style="display: none;">
        <div id="gameStatus" class="game-status"></div>
        
        <div class="game-container">
          <!-- Active Cards Area -->
          <div class="game-section">
            <h3>Active Cards</h3>
            <div id="activeCardsArea" class="active-cards-area"></div>
          </div>
          
          <!-- Player's Cards -->
          <div class="game-section">
            <h3>Your Cards</h3>
            <div id="playerScoreDisplay" class="player-score-display"></div>
            <div class="player-cards-container">
              <div class="keepsakes-area"></div>
              <div id="playerCards" class="player-cards"></div>
            </div>
          </div>
          
          <!-- Opponents' Cards -->
          <div class="game-section">
            <h3>Opponents</h3>
            <div id="opponentsArea" class="opponents-area"></div>
          </div>
          
          <!-- Scoring Area -->
          <div id="scoringArea" class="game-section scoring-section" style="display: none;">
            <h3>Scoring Phase</h3>
            <div id="abilityCards" class="ability-cards"></div>
            <button id="doneScoring" class="btn primary-btn">Done Scoring</button>
          </div>
          
          <!-- New Game Button (hidden initially) -->
          <button id="newGameBtn" class="btn primary-btn" style="display: none;">New Game</button>
        </div>
      </div>
    </main>
  </div>
  
  <!-- Card Preview Modal -->
  <div id="cardPreviewModal" class="card-preview-modal">
    <div class="card-preview-content">
      <img id="cardPreviewImage" class="card-preview-image" src="" alt="Card Preview">
      <div class="card-preview-info">
        <div id="cardPreviewName" class="card-preview-name"></div>
      </div>
      <button id="cardPreviewClose" class="card-preview-close">Close</button>
    </div>
  </div>
  
  <script>
    // Simplified room joining mechanism - initialize socket first
    const socket = io();
    
    // Variables for room and player
    const roomCode = '<%= roomCode %>';
    const nickname = '<%= nickname %>';
    let currentPlayerId = '';
    let currentRoomCode = roomCode;
    let isHost = false; // Track if current player is host
    let pinkLarkspurAbilityInProgress = false;
    let snapdragonAbilityInProgress = false;
    let snapdragonMovesUsed = 0;  // Track how many Snapdragon moves have been used
    let marigoldAbilityInProgress = false;
    let cardPositions = new Map(); // Store card positions for consistent rendering
    
    // Card sprite mapping - maps card IDs to their position in the spritesheet
    // Spritesheet layout: 7 columns √ó 4 rows, left to right, top to bottom
    const cardSpriteMap = {
      // Row 0: Red Rose, Camellia, Red Tulip, Amaryllis, Orchid, Gardenia, Daisy
      'red-rose': { row: 0, col: 0 },
      'camellia': { row: 0, col: 1 },
      'red-tulip': { row: 0, col: 2 },
      'amaryllis': { row: 0, col: 3 },
      'orchid': { row: 0, col: 4 },
      'gardenia': { row: 0, col: 5 },
      'daisy': { row: 0, col: 6 },
      
      // Row 1: Peony, Phlox, Pink Rose, Pink Larkspur, Carnation, Honeysuckle, Marigold
      'peony': { row: 1, col: 0 },
      'phlox': { row: 1, col: 1 },
      'pink-rose': { row: 1, col: 2 },
      'pink-larkspur': { row: 1, col: 3 },
      'carnation': { row: 1, col: 4 },
      'honeysuckle': { row: 1, col: 5 },
      'marigold': { row: 1, col: 6 },
      
      // Row 2: Hyacinth, Snapdragon, Forget-Me-Not, Violet, Ivy, Wormwood, Fern
      'hyacinth': { row: 2, col: 0 },
      'snapdragon': { row: 2, col: 1 },
      'forget-me-not': { row: 2, col: 2 },
      'violet': { row: 2, col: 3 },
      'ivy': { row: 2, col: 4 },           // Expansion card
      'wormwood': { row: 2, col: 5 },      // Expansion card
      'fern': { row: 2, col: 6 },          // Expansion card
      
      // Row 3: Eucalyptus, Bay Laurel, Nasturtium, Daylily, Butterfly Weed, Trumpet Vine, Card Back
      'eucalyptus': { row: 3, col: 0 },    // Expansion card
      'bay-laurel': { row: 3, col: 1 },    // Expansion card
      'nasturtium': { row: 3, col: 2 },    // Expansion card
      'daylily': { row: 3, col: 3 },       // Expansion card
      'butterfly-weed': { row: 3, col: 4 }, // Expansion card
      'trumpet-vine': { row: 3, col: 5 },  // Expansion card
      'card-back': { row: 3, col: 6 }      // Card back design
    };
    
    // Long press timer
    let longPressTimer = null;
    let longPressTarget = null;
    let longPressTriggered = false;  // Track if long press was triggered to prevent click
    
    // DOM Elements
    const playersList = document.getElementById('playersList');
    const startGameBtn = document.getElementById('startGameBtn');
    const waitingArea = document.getElementById('waitingArea');
    const gameArea = document.getElementById('gameArea');
    const roomCodeDisplay = document.getElementById('roomCodeDisplay');
    const activeCardsArea = document.getElementById('activeCardsArea');
    const playerCards = document.getElementById('playerCards');
    const opponentsArea = document.getElementById('opponentsArea');
    const gameStatus = document.getElementById('gameStatus');
    const scoringArea = document.getElementById('scoringArea');
    const doneScoring = document.getElementById('doneScoring');
    const newGameBtn = document.getElementById('newGameBtn');
    
    // Copy room link functionality
    document.getElementById('copyRoomLink').addEventListener('click', () => {
      const link = `${window.location.origin}/?join=${roomCode}`;
      navigator.clipboard.writeText(link)
        .then(() => {
          alert('Room link copied to clipboard! When others open this link, they will be prompted to enter a nickname.');
        })
        .catch(err => {
          console.error('Could not copy link: ', err);
        });
    });
    
    // Socket event handlers
    socket.on('connect', () => {
      console.log('Socket connected with ID:', socket.id);
      
      // Auto-join room if nickname is provided
      if (nickname) {
        console.log('Auto-joining room with nickname:', nickname);
        socket.emit('joinRoom', { roomCode, nickname });
      }
    });
    
    socket.on('updatePlayers', ({ players, canStart, hostId }) => {
      console.log('Received updatePlayers event. Players:', players, 'hostId:', hostId);
      updatePlayersList(players, hostId);
      
      // Track if current player is host
      isHost = hostId === socket.id;
      console.log('Am I host?', isHost ? 'YES' : 'NO');
      
      if (startGameBtn) {
        // Only enable the button for the host and if there are enough players
        startGameBtn.disabled = !canStart || !isHost;
        
        // Show a message if player is not host
        const hostMessage = document.getElementById('hostMessage') || createHostMessage();
        hostMessage.style.display = isHost ? 'none' : 'block';
      }
    });
    
    // Create and insert host message
    function createHostMessage() {
      const hostMessage = document.createElement('p');
      hostMessage.id = 'hostMessage';
      hostMessage.classList.add('lobby-help');
      hostMessage.textContent = 'Only the room host can start the game';
      
      // Insert after the start game button
      if (startGameBtn && startGameBtn.parentNode) {
        startGameBtn.parentNode.insertBefore(hostMessage, startGameBtn.nextSibling);
      }
      
      return hostMessage;
    }
    
    socket.on('gameStarted', () => {
      console.log('Game has started!');
      waitingArea.style.display = 'none';
      gameArea.style.display = 'block';
    });
    
    socket.on('updateGameState', (gameState) => {
      console.log('Received game state:', gameState);
      updateGameUI(gameState);
    });
    
    socket.on('gameReset', () => {
      console.log('Received gameReset event from server');
      resetGame();
    });
    
    // Handle game ending due to disconnect
    socket.on('gameEndedByDisconnect', ({ message, finalScores, players, canStart, hostId }) => {
      console.log('Game ended by disconnect:', message, finalScores);
      
      // Show notification
      const notification = document.createElement('div');
      notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #ff9800; color: white; padding: 1rem 2rem; border-radius: 8px; z-index: 10000; box-shadow: 0 4px 6px rgba(0,0,0,0.2); text-align: center;';
      notification.innerHTML = `<strong>${message}</strong>`;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.transition = 'opacity 0.3s';
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
      }, 4000);
      
      // Reset game UI
      resetGame();
      
      // Show final scores if available
      if (finalScores && finalScores.length > 0) {
        displayFinalScoresInWaiting(finalScores);
      }
      
      // Update players list
      updatePlayersList(players, hostId);
      isHost = hostId === socket.id;
      
      if (startGameBtn) {
        startGameBtn.disabled = !canStart || !isHost;
      }
    });
    
    socket.on('error', (message) => {
      console.error('Socket error:', message);
      alert(message);
    });
    
    socket.on('playerLeft', ({ players, canStart, hostId, hostChanged }) => {
      console.log('Player left, remaining players:', players, 'host:', hostId);
      updatePlayersList(players, hostId);
      
      // Update host status
      isHost = hostId === socket.id;
      
      if (startGameBtn) {
        startGameBtn.disabled = !canStart || !isHost;
      }
      
      // Notify if host changed
      if (hostChanged && isHost) {
        const notification = document.createElement('div');
        notification.classList.add('notification');
        notification.textContent = 'You are now the room host';
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
          notification.remove();
        }, 5000);
      }
    });
    
    // Game control event handlers
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        console.log('Starting game...');
        socket.emit('startGame', { roomCode });
      });
    }
    
    if (doneScoring) {
      doneScoring.addEventListener('click', () => {
        socket.emit('doneScoring', { roomCode });
        doneScoring.disabled = true;
      });
    }
    
    if (newGameBtn) {
      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked, sending request to server');
        socket.emit('newGame', { roomCode });
        
        // Disable the button temporarily to prevent multiple clicks
        newGameBtn.disabled = true;
        newGameBtn.textContent = 'Starting New Game...';
        
        // Re-enable after a delay
        setTimeout(() => {
          newGameBtn.disabled = false;
          newGameBtn.textContent = 'New Game';
          newGameBtn.style.display = 'none';
        }, 1000);
      });
    }
    
    // Helper Functions
    function updatePlayersList(players, hostId) {
      if (!playersList) return;
      
      console.log('Updating players list with:', players, 'host:', hostId);
      playersList.innerHTML = '';
      
      players.forEach(player => {
        const playerItem = document.createElement('div');
        playerItem.classList.add('player-item');
        
        if (player.id === socket.id) {
          playerItem.classList.add('current-player');
          currentPlayerId = player.id;
        }
        
        // Mark host player
        if (player.id === hostId) {
          playerItem.classList.add('host');
        }
        
        // Player name with host tag if applicable
        playerItem.innerHTML = `
          ${player.nickname}
          ${player.id === hostId ? '<span class="host-indicator">HOST</span>' : ''}
        `;
        
        playersList.appendChild(playerItem);
      });
    }
    
    function updateGameUI(gameState) {
      // First, determine if we are the current player
      const isCurrentPlayer = gameState.currentPlayerId === currentPlayerId;
      const isReceivingPlayer = gameState.receivingPlayerId === currentPlayerId;
      
      // Update round information if available
      updateRoundInfo(gameState);
      
      // Update game status message
      updateGameStatus(gameState, isCurrentPlayer, isReceivingPlayer);
      
      // Handle turn timer
      if (gameState.phase === 'offering' && isCurrentPlayer) {
        startTurnTimer();
      } else if (gameState.phase === 'selection' && isReceivingPlayer) {
        startTurnTimer();
      } else if (gameState.phase !== 'offering' && gameState.phase !== 'selection') {
        clearTurnTimer();
      }
      
      // Set game phase attribute for CSS targeting
      if (gameArea) {
        gameArea.setAttribute('data-phase', gameState.phase);
      }
      
      // Update active cards area
      updateActiveCards(gameState.activeCards, gameState.phase, isCurrentPlayer, isReceivingPlayer);
      
      // Find current player data
      const currentPlayerData = gameState.players.find(p => p.id === currentPlayerId);
      
      // Update player's cards
      if (currentPlayerData) {
        updatePlayerCards(currentPlayerData);
      }
      
      // Update opponents' cards
      updateOpponentsCards(gameState.players);
      
      // Show/hide scoring UI
      if (gameState.phase === 'scoring') {
        showScoringUI(currentPlayerData, gameState);
      } else {
        hideScoringUI();
      }
      
      // Show game over UI if game is over
      if (gameState.phase === 'gameOver') {
        showGameOverUI(gameState.players);
      }
    }
    
    // Update round information display
    function updateRoundInfo(gameState) {
      // Create or update round info display if it doesn't exist
      let roundInfoElement = document.getElementById('roundInfo');
      if (!roundInfoElement) {
        roundInfoElement = document.createElement('div');
        roundInfoElement.id = 'roundInfo';
        roundInfoElement.classList.add('round-info');
        
        // Insert after game status
        const gameStatus = document.getElementById('gameStatus');
        if (gameStatus && gameStatus.parentNode) {
          gameStatus.parentNode.insertBefore(roundInfoElement, gameStatus.nextSibling);
        }
      }
      
      if (gameState.gameRound) {
        roundInfoElement.innerHTML = `<strong>Round ${gameState.gameRound} of 3</strong>`;
        roundInfoElement.style.display = 'block';
      } else {
        roundInfoElement.style.display = 'none';
      }
    }
    
    function updateGameStatus(gameState, isCurrentPlayer, isReceivingPlayer) {
      if (!gameStatus) return;
      
      let statusText = '';
      
      switch (gameState.phase) {
        case 'offering':
          if (isCurrentPlayer) {
            statusText = 'Your turn! Choose a card to hide (flip face-down).';
          } else {
            const currentPlayer = gameState.players.find(p => p.id === gameState.currentPlayerId);
            statusText = `${currentPlayer?.nickname || 'Current player'} is choosing a card to hide...`;
          }
          break;
          
        case 'selection':
          if (isReceivingPlayer) {
            statusText = 'Choose which card to take into your bouquet.';
          } else {
            const receivingPlayer = gameState.players.find(p => p.id === gameState.receivingPlayerId);
            statusText = `${receivingPlayer?.nickname || 'Next player'} is choosing a card...`;
          }
          break;
          
        case 'scoring':
          statusText = 'Scoring phase! Use your card abilities before final scoring.';
          break;
          
        case 'gameOver':
          statusText = 'Game over! Final scores are shown.';
          break;
      }
      
      gameStatus.textContent = statusText;
    }
    
    function updateActiveCards(activeCards, phase, isCurrentPlayer, isReceivingPlayer) {
      if (!activeCardsArea) return;
      
      // Find the parent game-section that contains the active cards area
      const activeCardsSection = activeCardsArea.closest('.game-section');
      
      // Hide the entire section during scoring or game over phases
      if (activeCardsSection) {
        if (phase === 'scoring' || phase === 'gameOver') {
          activeCardsSection.style.display = 'none';
          return; // Exit early, no need to update content for a hidden section
        } else {
          activeCardsSection.style.display = 'block';
        }
      }
      
      console.log('Updating active cards:', activeCards);
      activeCardsArea.innerHTML = '';
      
      if (!activeCards || activeCards.length === 0) {
        console.log('No active cards to display');
        return;
      }
      
      // Add a message for receiving player during offering phase
      if (phase === 'offering' && isReceivingPlayer) {
        const waitingMessage = document.createElement('div');
        waitingMessage.classList.add('waiting-message');
        waitingMessage.textContent = 'Waiting for other player to choose a card to hide...';
        activeCardsArea.appendChild(waitingMessage);
        return;
      }
      
      // Create and add card elements
      activeCards.forEach((card, index) => {
        console.log('Creating card element for active card:', card);
        
        // During offering phase, cards are only visible to current player
        const shouldShowCard = !(phase === 'offering' && !isCurrentPlayer);
        
        const cardElement = createCardElement(card, false, shouldShowCard);
        
        // Add click handler based on game phase
        if (phase === 'offering' && isCurrentPlayer) {
          // Only face-up cards can be flipped in the offering phase
          if (card.faceUp) {
            cardElement.classList.add('selectable');
            cardElement.addEventListener('click', () => {
              console.log('Hiding card at index', index);
              socket.emit('flipCard', { roomCode, cardIndex: index });
            });
          }
        } else if (phase === 'selection' && isReceivingPlayer) {
          // Both face-up and face-down cards can be selected
          cardElement.classList.add('selectable');
          cardElement.addEventListener('click', () => {
            console.log('Selecting card at index', index);
            socket.emit('selectCard', { roomCode, cardIndex: index });
          });
        }
        
        activeCardsArea.appendChild(cardElement);
      });
    }
    
    function updatePlayerCards(playerData) {
      if (!playerCards) return;
      
      // Clear current cards
      playerCards.innerHTML = '';
      
      // Create card elements
      playerData.cards.forEach((card) => {
        const cardElement = createCardElement(card);
        cardElement.classList.add('player-card');
        cardElement.dataset.location = card.location;
        
        // Add a class for keepsake cards to apply the shifted positioning
        if (card.location === 'keepsakes') {
          cardElement.classList.add('keepsake-card');
          
          // Add a small label to indicate keepsake
          const label = document.createElement('div');
          label.className = 'card-label';
          label.textContent = 'Keepsake';
          cardElement.appendChild(label);
        } else {
          // Add bouquet label for scoring phase
          const label = document.createElement('div');
          label.className = 'card-label';
          label.textContent = 'Bouquet';
          cardElement.appendChild(label);
        }
        
        // Highlight cards with abilities during scoring phase
        if (hasAbility(card.id) && gameArea.getAttribute('data-phase') === 'scoring' && !card.abilityUsed) {
          cardElement.classList.add('has-ability');
          
          // Add click handler for ability activation
          cardElement.addEventListener('click', () => {
            handleCardAbility(card.id, playerData);
          });
        }
        
        // Apply smooth animation for cards that move between bouquet and keepsakes
        const prevPos = cardPositions.get(card.id);
        if (prevPos) {
          const isMovedCard = (prevPos.isKeepsake && card.location === 'bouquet') || 
                             (!prevPos.isKeepsake && card.location === 'keepsakes');
          
          if (isMovedCard) {
            cardElement.style.transition = 'transform 0.5s ease-in-out, opacity 0.3s';
            cardElement.style.opacity = '0';
            
            // Enable animation after a short delay to ensure positions are calculated
            setTimeout(() => {
              cardElement.style.opacity = '1';
            }, 50);
          }
        }
        
        playerCards.appendChild(cardElement);
      });
      
      // Update player score display
      const playerScoreDisplay = document.getElementById('playerScoreDisplay');
      if (playerScoreDisplay && playerData.score !== undefined) {
        playerScoreDisplay.style.display = 'block';
        playerScoreDisplay.innerHTML = `
          <div>Round Score: ${playerData.score || 0}</div>
          <div>Total Score: ${playerData.totalScore || 0}</div>
        `;
      }
    }
    
    function updateOpponentsCards(players) {
      if (!opponentsArea) return;
      
      // Clear current opponents
      opponentsArea.innerHTML = '';
      
      // Add each opponent
      players.forEach(player => {
        if (player.id === currentPlayerId) return; // Skip current player
        
        const opponentElement = document.createElement('div');
        opponentElement.classList.add('opponent');
        
        // Add opponent name
        const nameElement = document.createElement('div');
        nameElement.classList.add('opponent-name');
        nameElement.textContent = player.nickname;
        opponentElement.appendChild(nameElement);
        
        // Add opponent scores
        if (player.score !== undefined) {
          const scoreContainer = document.createElement('div');
          scoreContainer.classList.add('opponent-scores');
          
          const roundScoreElement = document.createElement('div');
          roundScoreElement.classList.add('opponent-round-score');
          roundScoreElement.textContent = `Round Score: ${player.score}`;
          scoreContainer.appendChild(roundScoreElement);
          
          const totalScoreElement = document.createElement('div');
          totalScoreElement.classList.add('opponent-total-score');
          totalScoreElement.textContent = `Total Score: ${player.totalScore || 0}`;
          scoreContainer.appendChild(totalScoreElement);
          
          opponentElement.appendChild(scoreContainer);
        }
        
        // Add opponent's cards in a single container
        const cardsContainer = document.createElement('div');
        cardsContainer.classList.add('opponent-cards-container');
        
        // Add keepsakes background area
        const keepsakesArea = document.createElement('div');
        keepsakesArea.classList.add('keepsakes-area');
        cardsContainer.appendChild(keepsakesArea);
        
        const cardsElement = document.createElement('div');
        cardsElement.classList.add('opponent-cards');
        
        // Sort cards to maintain order (if we had a way to track original order)
        const sortedCards = [...player.cards];
        
        sortedCards.forEach(card => {
          const cardElement = createCardElement(card, true);
          if (card.location === 'keepsakes') {
            cardElement.classList.add('keepsake-card');
          }
          cardsElement.appendChild(cardElement);
        });
        
        cardsContainer.appendChild(cardsElement);
        opponentElement.appendChild(cardsContainer);
        opponentsArea.appendChild(opponentElement);
      });
    }
    
    function showScoringUI(playerData, gameState) {
      if (!scoringArea || !doneScoring) return;
      
      // Mark the game area with current phase for CSS targeting
      gameArea.setAttribute('data-phase', 'scoring');
      
      scoringArea.style.display = 'block';
      
      // Check if the player has an unused marigold ability card
      const allCards = [...(playerData.bouquet || []), ...(playerData.keepsakes || [])];
      const hasUnusedMarigold = allCards.some(card => card.id === 'marigold' && !card.abilityUsed);
      
      // Disable the Done Scoring button if an unused marigold exists
      doneScoring.disabled = hasUnusedMarigold || playerData?.doneScoring;
      
      // If there is an unused marigold, display a warning message
      let warningElement = document.getElementById('marigoldWarning');
      if (hasUnusedMarigold) {
        if (!warningElement) {
          warningElement = document.createElement('div');
          warningElement.id = 'marigoldWarning';
          warningElement.classList.add('ability-warning');
          warningElement.innerHTML = '‚ö†Ô∏è You must use Marigold\'s ability (discard one card) before finishing scoring.';
          scoringArea.insertBefore(warningElement, doneScoring);
        }
      } else if (warningElement) {
        warningElement.remove();
      }
      
      // Add card ability instructions instead of duplicating the cards
      const abilityCardsContainer = document.getElementById('abilityCards');
      if (abilityCardsContainer) {
        abilityCardsContainer.innerHTML = '';
        
        // Find cards with abilities
        const cardsWithAbilities = [
          ...(playerData.bouquet || []).filter(card => hasAbility(card.id) && !card.abilityUsed),
          ...(playerData.keepsakes || []).filter(card => hasAbility(card.id) && !card.abilityUsed)
        ];
        
        if (cardsWithAbilities.length > 0) {
          const instructionsElement = document.createElement('div');
          instructionsElement.classList.add('ability-instructions');
          
          const abilityNames = cardsWithAbilities.map(card => card.name).join(', ');
          instructionsElement.innerHTML = `
            <div>‚ö° <strong>Card Abilities Available</strong> ‚ö°</div>
            <div>Click on highlighted cards in your collection to use their abilities.</div>
            <div>Available: ${abilityNames}</div>
          `;
          
          abilityCardsContainer.appendChild(instructionsElement);
        }
      }
    }
    
    function hideScoringUI() {
      if (!scoringArea) return;
      
      scoringArea.style.display = 'none';
      
      // Remove scoring phase marker
      if (gameArea) {
        gameArea.removeAttribute('data-phase');
      }
      
      // Reset all ability flags and card positions
      pinkLarkspurAbilityInProgress = false;
      snapdragonAbilityInProgress = false;
      snapdragonMovesUsed = 0;  
      marigoldAbilityInProgress = false;
      cardPositions.clear();
    }
    
    function showGameOverUI(players) {
      if (!gameStatus) return;
      
      // Sort players by totalScore (highest first)
      const sortedPlayers = [...players].sort((a, b) => b.totalScore - a.totalScore);
      
      const resultsContainer = document.createElement('div');
      resultsContainer.classList.add('results-container');
      
      const resultsHeader = document.createElement('h2');
      resultsHeader.textContent = 'Final Scores';
      resultsContainer.appendChild(resultsHeader);
      
      // Add explanation about accumulated scores
      const explanation = document.createElement('p');
      explanation.classList.add('results-explanation');
      explanation.textContent = 'Scores accumulated over 3 rounds';
      resultsContainer.appendChild(explanation);
      
      sortedPlayers.forEach((player, index) => {
        const playerResult = document.createElement('div');
        playerResult.classList.add('player-result');
        
        if (index === 0) {
          playerResult.classList.add('winner');
        }
        
        if (player.id === currentPlayerId) {
          playerResult.classList.add('current-player');
        }
        
        // Create round scores display
        let roundScoresHtml = '';
        if (player.roundScores && player.roundScores.length > 0) {
          roundScoresHtml = '<div class="round-scores">';
          player.roundScores.forEach((score, idx) => {
            roundScoresHtml += `<span class="round-score">Round ${idx + 1}: ${score}</span>`;
          });
          roundScoresHtml += '</div>';
        }
        
        playerResult.innerHTML = `
          <div class="result-player-name">${player.nickname}</div>
          <div class="result-player-score">${player.totalScore} points</div>
          ${roundScoresHtml}
        `;
        
        resultsContainer.appendChild(playerResult);
      });
      
      // Clear existing results before adding new ones
      const existingResults = document.querySelector('.results-container');
      if (existingResults) {
        existingResults.remove();
      }
      
      // Only show new game button to host
      if (newGameBtn) {
        newGameBtn.style.display = isHost ? 'block' : 'none';
        
        // Add info message for non-hosts
        let hostInfoMsg = document.getElementById('gameOverHostMsg');
        if (!isHost) {
          if (!hostInfoMsg) {
            hostInfoMsg = document.createElement('p');
            hostInfoMsg.id = 'gameOverHostMsg';
            hostInfoMsg.classList.add('host-info-message');
            hostInfoMsg.textContent = 'Waiting for host to start a new game...';
            gameArea.appendChild(hostInfoMsg);
          }
        } else if (hostInfoMsg) {
          hostInfoMsg.remove();
        }
      }
      
      // Add results to game area
      gameArea.appendChild(resultsContainer);
    }
    
    function resetGame() {
      console.log('Resetting game...');
      
      // Reset all ability flags and card positions
      pinkLarkspurAbilityInProgress = false;
      snapdragonAbilityInProgress = false;
      snapdragonMovesUsed = 0;  
      marigoldAbilityInProgress = false;
      cardPositions.clear();
      
      // Hide game over elements
      if (newGameBtn) {
        newGameBtn.style.display = 'none';
      }
      
      // Remove host info message
      const hostInfoMsg = document.getElementById('gameOverHostMsg');
      if (hostInfoMsg) {
        hostInfoMsg.remove();
      }
      
      // Remove results container
      const existingResults = document.querySelector('.results-container');
      if (existingResults) {
        existingResults.remove();
      }
      
      // Clear player cards
      if (playerCards) {
        playerCards.innerHTML = '';
      }
      
      // Clear opponents area
      if (opponentsArea) {
        opponentsArea.innerHTML = '';
      }
      
      // Clear active cards
      if (activeCardsArea) {
        activeCardsArea.innerHTML = '';
      }
      
      // Clear turn timer
      clearTurnTimer();
      
      // For proper flow in the new game, show waiting area, hide game area
      if (waitingArea && gameArea) {
        waitingArea.style.display = 'block';
        gameArea.style.display = 'none';
      }
      
      // Reset game status
      if (gameStatus) {
        gameStatus.textContent = 'New game is ready to start!';
      }
      
      console.log('Game reset complete');
    }
    
    // Display final scores in waiting room
    function displayFinalScoresInWaiting(finalScores) {
      // Remove any existing scores display
      const existingScores = document.getElementById('previousGameScores');
      if (existingScores) {
        existingScores.remove();
      }
      
      // Sort scores by total score (descending)
      const sortedScores = [...finalScores].sort((a, b) => b.totalScore - a.totalScore);
      
      // Create scores display
      const scoresContainer = document.createElement('div');
      scoresContainer.id = 'previousGameScores';
      scoresContainer.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1.5rem; border-radius: 12px; margin: 1rem 0; box-shadow: 0 4px 12px rgba(0,0,0,0.15);';
      
      const title = document.createElement('h3');
      title.textContent = 'üèÜ Previous Game Results';
      title.style.cssText = 'margin: 0 0 1rem 0; text-align: center; font-size: 1.3rem;';
      scoresContainer.appendChild(title);
      
      sortedScores.forEach((player, index) => {
        const playerDiv = document.createElement('div');
        playerDiv.style.cssText = 'background: rgba(255,255,255,0.15); padding: 0.75rem; margin: 0.5rem 0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';
        
        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
        
        playerDiv.innerHTML = `
          <span style="font-weight: bold; font-size: 1.1rem;">${medal} ${player.nickname}</span>
          <span style="font-size: 1.2rem; font-weight: bold;">${player.totalScore} pts</span>
        `;
        
        scoresContainer.appendChild(playerDiv);
      });
      
      // Insert after players list
      const playersList = document.getElementById('playersList');
      if (playersList && playersList.parentNode) {
        playersList.parentNode.insertBefore(scoresContainer, playersList.nextSibling);
      }
    }
    
    function createCardElement(card, isOpponent = false, isVisible = true) {
      if (!card) {
        console.error('Attempted to create card element with undefined card');
        return document.createElement('div'); // Return empty div to avoid errors
      }
      
      console.log('Creating card element for:', card, 'visible:', isVisible);
      const cardElement = document.createElement('div');
      cardElement.classList.add('card');
      cardElement.dataset.cardId = card.id;
      
      // Apply hidden state if card should not be visible
      if (!isVisible) {
        cardElement.classList.add('hidden-card');
        
        // Add mystery placeholder
        const mysteryContent = document.createElement('div');
        mysteryContent.classList.add('card-mystery');
        mysteryContent.innerHTML = '<span>?</span>';
        cardElement.appendChild(mysteryContent);
        return cardElement;
      }
      
      if (card.faceUp) {
        cardElement.classList.add('face-up');
        cardElement.classList.add(card.color);
        
        // Card content for face-up card
        const cardHeader = document.createElement('div');
        cardHeader.classList.add('card-header');
        
        const cardName = document.createElement('div');
        cardName.classList.add('card-name');
        cardName.textContent = card.name;
        cardHeader.appendChild(cardName);
        
        // Add hearts
        const cardHearts = document.createElement('div');
        cardHearts.classList.add('card-hearts');
        for (let i = 0; i < card.hearts; i++) {
          const heart = document.createElement('span');
          heart.textContent = '‚ù§Ô∏è';
          cardHearts.appendChild(heart);
        }
        cardHeader.appendChild(cardHearts);
        cardElement.appendChild(cardHeader);
        
        // Card effect text
        const cardEffect = document.createElement('div');
        cardEffect.classList.add('card-effect');
        cardEffect.textContent = card.effectText;
        cardElement.appendChild(cardEffect);
        
        // Card flavor text
        const cardFlavor = document.createElement('div');
        cardFlavor.classList.add('card-flavor');
        cardFlavor.textContent = card.flavorText;
        cardElement.appendChild(cardFlavor);
      } else {
        cardElement.classList.add('face-down');
        
        // Simple card back design
        const cardBack = document.createElement('div');
        cardBack.classList.add('card-back');
        cardBack.textContent = 'Tussie Mussie';
        cardElement.appendChild(cardBack);
      }
      
      // Make opponent cards smaller
      if (isOpponent) {
        cardElement.classList.add('opponent-card');
      }
      
      // Set up long-press for face-up cards
      if (card.faceUp && card.id) {
        setupCardLongPress(cardElement, card.id, card.name);
      }
      
      return cardElement;
    }
    
    function hasAbility(cardId) {
      return ['pink-larkspur', 'snapdragon', 'marigold'].includes(cardId);
    }
    
    function handleCardAbility(cardId, playerData) {
      // For simplicity, we'll implement only a basic UI for abilities
      switch (cardId) {
        case 'pink-larkspur':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || snapdragonAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Set flag to indicate ability is in progress
          pinkLarkspurAbilityInProgress = true;
          
          // First, draw two cards from the deck
          socket.emit('useCardAbility', {
            roomCode,
            cardId: 'pink-larkspur'
          });

          // Create a persistent function to handle both steps of the ability
          function handlePinkLarkspurResponse(result) {
            console.log("Pink larkspur response:", result);
            
            // Step 1: Process drawn cards
            if (result.ability === 'pink-larkspur-draw' && result.drawnCards) {
              showDrawnCardsSelection(result.drawnCards, (selectedDrawnCardIndex) => {
                // Save the selected card index for step 2
                const selectedCard = result.drawnCards[selectedDrawnCardIndex];
                console.log("Selected drawn card:", selectedCard);
                
                // After player selects a drawn card, prompt to select which card to replace
                showAbilityInstructions('Now select one of your cards to replace with the chosen card.');
                
                // Get all player cards and make them selectable
                const allPlayerCards = document.querySelectorAll('.player-card');
                allPlayerCards.forEach(cardElement => {
                  // Add visual indicators
                  cardElement.classList.add('selectable');
                  
                  // Add hover effect
                  cardElement.addEventListener('mouseenter', function() {
                    this.style.boxShadow = '0 0 10px 5px rgba(255, 0, 0, 0.5)';
                    this.style.opacity = '0.8';
                  });
                  
                  cardElement.addEventListener('mouseleave', function() {
                    this.style.boxShadow = '';
                    this.style.opacity = '1';
                  });
                  
                  // Add click handler for selection
                  cardElement.addEventListener('click', function cardClickHandler() {
                    // Remove event listeners from all cards
                    allPlayerCards.forEach(c => {
                      c.classList.remove('selectable');
                      c.style.boxShadow = '';
                      c.style.opacity = '1';
                      c.removeEventListener('mouseenter', arguments.callee);
                      c.removeEventListener('mouseleave', arguments.callee);
                      c.removeEventListener('click', cardClickHandler);
                    });
                    
                    const targetCardId = this.dataset.cardId;
                    console.log("Selected player card to replace:", targetCardId);
                    
                    // Visual feedback for the card being replaced
                    this.style.transition = 'all 0.3s ease';
                    this.style.opacity = '0';
                    this.style.transform = 'scale(0.8)';
                    
                    // Send the card replacement request
                    socket.emit('useCardAbility', {
                      roomCode,
                      cardId: 'pink-larkspur',
                      targetCardId: `${selectedDrawnCardIndex}|${targetCardId}`
                    });
                    
                    hideAbilityInstructions();
                  });
                });
              });
            } 
            // Step 2: Handle replacement confirmation
            else if (result.ability === 'pink-larkspur-replace') {
              console.log("Card replacement successful");
              // Clean up the event listener
              socket.off('cardAbilityResult', handlePinkLarkspurResponse);
              // Reset the ability flag
              pinkLarkspurAbilityInProgress = false;
            }
          }
          
          // Listen for both steps of the ability process
          socket.on('cardAbilityResult', handlePinkLarkspurResponse);
          break;
        
        case 'snapdragon':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Check if we've already used both Snapdragon moves
          if (snapdragonMovesUsed >= 2) {
            alert('You have already used Snapdragon\'s ability twice.');
            return;
          }
          
          // Set flag to indicate ability is in progress
          snapdragonAbilityInProgress = true;
          
          // Allow player to move up to 2 cards between bouquet and keepsakes
          const movesRemaining = 2 - snapdragonMovesUsed;
          alert(`Snapdragon: Click a card to move it between bouquet and keepsakes. (${movesRemaining} move${movesRemaining > 1 ? 's' : ''} remaining)`);
          
          // Add click handlers to all player cards
          const playerCards = document.querySelectorAll('.player-card');
          
          // Store current positions of all cards before movement
          playerCards.forEach((card, index) => {
            if (card.dataset.cardId) {
              const rect = card.getBoundingClientRect();
              cardPositions.set(card.dataset.cardId, {
                index: index,
                left: rect.left,
                top: rect.top,
                isKeepsake: card.classList.contains('keepsake-card')
              });
            }
          });
          
          playerCards.forEach(cardElement => {
            cardElement.classList.add('selectable');
            
            // Add hover effect to preview movement
            cardElement.addEventListener('mouseenter', () => {
              const isKeepsake = cardElement.classList.contains('keepsake-card');
              cardElement.style.transition = 'transform 0.2s ease';
              cardElement.style.transform = isKeepsake ? 'translateY(-30px)' : 'translateY(30px)';
            });
            
            cardElement.addEventListener('mouseleave', () => {
              cardElement.style.transition = 'transform 0.2s ease';
              cardElement.style.transform = '';
            });
            
            cardElement.addEventListener('click', () => {
              const targetCardId = cardElement.dataset.cardId;
              const isKeepsake = cardElement.classList.contains('keepsake-card');
              
              // Toggle the keepsake state for this card in position tracking
              if (cardPositions.has(targetCardId)) {
                const pos = cardPositions.get(targetCardId);
                pos.isKeepsake = !pos.isKeepsake;
              }
              
              // Animate the card movement immediately for visual feedback
              cardElement.style.transition = 'transform 0.5s ease, top 0.5s ease';
              
              if (isKeepsake) {
                // Move from keepsake to bouquet (move up)
                cardElement.style.transform = 'translateY(-30px)';
                setTimeout(() => {
                  cardElement.classList.remove('keepsake-card');
                }, 100);
              } else {
                // Move from bouquet to keepsake (move down)
                cardElement.style.transform = 'translateY(30px)';
                setTimeout(() => {
                  cardElement.classList.add('keepsake-card');
                }, 100);
              }
              
              // Send the move to server
              socket.emit('useCardAbility', {
                roomCode,
                cardId: 'snapdragon',
                targetCardId
              });
              
              // Increment the counter for Snapdragon moves
              snapdragonMovesUsed++;
              
              // Force a layout recalculation to make other cards update positions
              requestAnimationFrame(() => {
                // Remove selection state from all cards
                playerCards.forEach(c => {
                  c.classList.remove('selectable');
                  
                  // Remove hover event listeners
                  c.onmouseenter = null;
                  c.onmouseleave = null;
                });
              });
              
              // Reset the ability in progress flag to allow another use
              snapdragonAbilityInProgress = false;
              
              // If we've used both moves, show a message
              if (snapdragonMovesUsed >= 2) {
                alert('You have used both Snapdragon ability moves.');
              } else {
                // Show how many moves are left
                setTimeout(() => {
                  alert(`Snapdragon: You have ${2 - snapdragonMovesUsed} move remaining. Click on the Snapdragon card again to use it.`);
                }, 500);
              }
            }, { once: true });
          });
          break;
          
        case 'marigold':
          // Check if ability is already in progress to prevent recursion
          if (pinkLarkspurAbilityInProgress || snapdragonAbilityInProgress || marigoldAbilityInProgress) return;
          
          // Set flag to indicate ability is in progress
          marigoldAbilityInProgress = true;
          
          // Player must discard one card
          alert('Marigold: You must discard one of your other cards.');
          
          // Store current positions of all cards before discard
          const allCards = document.querySelectorAll('.player-card');
          allCards.forEach((card, index) => {
            if (card.dataset.cardId) {
              const rect = card.getBoundingClientRect();
              cardPositions.set(card.dataset.cardId, {
                index: index,
                left: rect.left,
                top: rect.top,
                isKeepsake: card.classList.contains('keepsake-card')
              });
            }
          });
          
          // Add click handlers to all player cards except Marigold
          const otherCards = document.querySelectorAll('.player-card:not([data-card-id="marigold"])');
          otherCards.forEach(cardElement => {
            cardElement.classList.add('selectable');
            
            // Add hover effect to preview discard
            cardElement.addEventListener('mouseenter', () => {
              cardElement.style.boxShadow = '0 0 10px 5px rgba(255, 0, 0, 0.5)';
              cardElement.style.opacity = '0.8';
              cardElement.style.transform = 'scale(0.95)';
            });
            
            cardElement.addEventListener('mouseleave', () => {
              cardElement.style.boxShadow = '';
              cardElement.style.opacity = '1';
              cardElement.style.transform = 'scale(1)';
            });
            
            cardElement.addEventListener('click', () => {
              const targetCardId = cardElement.dataset.cardId;
              
              // Visual effect for discard
              cardElement.style.transition = 'all 0.3s ease';
              cardElement.style.opacity = '0';
              cardElement.style.transform = 'scale(0.8)';
              
              // Send discard to server
              socket.emit('useCardAbility', {
                roomCode,
                cardId: 'marigold',
                targetCardId
              });
              
              // Remove selection state
              otherCards.forEach(c => {
                c.classList.remove('selectable');
                c.style.boxShadow = '';
                c.style.opacity = '1';
                c.style.transform = 'scale(1)';
                
                // Remove hover event listeners
                c.onmouseenter = null;
                c.onmouseleave = null;
              });
              
              // Reset the flag when ability is complete
              marigoldAbilityInProgress = false;
            }, { once: true });
          });
          break;
      }
    }
    
    // Helper function to show drawn cards and let player choose one
    function showDrawnCardsSelection(drawnCards, callback) {
      // Create a modal for card selection
      const modal = document.createElement('div');
      modal.classList.add('card-selection-modal');
      modal.innerHTML = `
        <div class="modal-content">
          <h3>Pink Larkspur Ability</h3>
          <p>Select one of these cards to add to your collection:</p>
          <div class="drawn-cards-container"></div>
        </div>
      `;
      
      // Style the modal
      const modalStyle = document.createElement('style');
      modalStyle.textContent = `
        .card-selection-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 1000;
        }
        .modal-content {
          background-color: white;
          padding: 20px;
          border-radius: 8px;
          max-width: 80%;
          text-align: center;
        }
        .drawn-cards-container {
          display: flex;
          justify-content: center;
          gap: 20px;
          margin-top: 20px;
        }
        .ability-instructions {
          position: fixed;
          top: 80px;
          left: 50%;
          transform: translateX(-50%);
          background-color: #fffde7;
          border: 1px solid #ffc107;
          padding: 10px 20px;
          border-radius: 4px;
          z-index: 1000;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
      `;
      
      document.head.appendChild(modalStyle);
      document.body.appendChild(modal);
      
      // Add the drawn cards to the modal
      const drawnCardsContainer = modal.querySelector('.drawn-cards-container');
      drawnCards.forEach((card, index) => {
        const cardElement = createCardElement(card);
        cardElement.classList.add('selectable');
        
        cardElement.addEventListener('click', () => {
          // Call the callback with the selected card index
          document.body.removeChild(modal);
          callback(index);
        });
        
        drawnCardsContainer.appendChild(cardElement);
      });
    }
    
    // Helper functions for ability instructions
    function showAbilityInstructions(text) {
      // Remove any existing instructions
      hideAbilityInstructions();
      
      // Create new instructions
      const instructions = document.createElement('div');
      instructions.id = 'abilityInstructions';
      instructions.classList.add('ability-instructions');
      instructions.textContent = text;
      
      document.body.appendChild(instructions);
    }
    
    function hideAbilityInstructions() {
      const instructions = document.getElementById('abilityInstructions');
      if (instructions) {
        instructions.parentNode.removeChild(instructions);
      }
    }
    
    // Turn timer functionality
    let timerInterval = null;
    const turnTimer = document.getElementById('turnTimer');
    const timerValue = document.getElementById('timerValue');
    const TURN_TIME = 30; // seconds
    let timeRemaining = TURN_TIME;
    
    function startTurnTimer() {
      // Clear any existing timer
      clearTurnTimer();
      
      // Reset time
      timeRemaining = TURN_TIME;
      updateTimerDisplay();
      
      // Show timer
      turnTimer.classList.add('visible');
      turnTimer.classList.remove('urgent');
      
      // Start countdown
      timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();
        
        // Make timer urgent when less than 10 seconds remain
        if (timeRemaining <= 10) {
          turnTimer.classList.add('urgent');
        }
        
        // Stop at 0
        if (timeRemaining <= 0) {
          clearInterval(timerInterval);
        }
      }, 1000);
    }
    
    function clearTurnTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      turnTimer.classList.remove('visible');
    }
    
    function updateTimerDisplay() {
      timerValue.textContent = `${timeRemaining}s`;
    }

    // Show round transition info
    function showRoundTransition(gameRound) {
      // Create a modal for round transition
      let transitionOverlay = document.getElementById('roundTransition');
      if (!transitionOverlay) {
        transitionOverlay = document.createElement('div');
        transitionOverlay.id = 'roundTransition';
        transitionOverlay.classList.add('round-transition');
        document.body.appendChild(transitionOverlay);
      }
      
      // Different content based on host status
      const actionContent = isHost 
        ? `<div class="continue-button" id="continueToNextRoundBtn">Continue to Next Round</div>`
        : `<div class="waiting-message">Waiting for host to start the next round...</div>`;
      
      transitionOverlay.innerHTML = `
        <div class="transition-content">
          <h2>Round ${gameRound - 1} Complete!</h2>
          <p>Moving to Round ${gameRound} of 3</p>
          ${actionContent}
        </div>
      `;
      
      // Show the overlay
      transitionOverlay.style.display = 'flex';
      
      // Add click handler to continue button (only for host)
      if (isHost) {
        document.getElementById('continueToNextRoundBtn').addEventListener('click', () => {
          // Send event to server that host clicked continue
          socket.emit('continueToNextRound', { roomCode });
          transitionOverlay.style.display = 'none';
        });
      }
      
      // No auto-hide timer - only dismissible by host action
    }
    
    // Listen for round transitions
    socket.on('roundComplete', ({ gameRound }) => {
      console.log('Round complete, moving to round:', gameRound);
      showRoundTransition(gameRound);
    });
    
    // Listen for continue to next round (triggered by host)
    socket.on('continueToNextRound', () => {
      console.log('Host continued to next round');
      // Hide the transition overlay for all players
      const transitionOverlay = document.getElementById('roundTransition');
      if (transitionOverlay) {
        transitionOverlay.style.display = 'none';
      }
    });
    
    // Card Preview Modal Functions
    const cardPreviewModal = document.getElementById('cardPreviewModal');
    const cardPreviewImage = document.getElementById('cardPreviewImage');
    const cardPreviewName = document.getElementById('cardPreviewName');
    const cardPreviewClose = document.getElementById('cardPreviewClose');
    
    function showCardPreview(cardId, cardName) {
      if (!cardSpriteMap[cardId]) {
        console.warn('No sprite mapping for card:', cardId);
        return;
      }
      
      const sprite = cardSpriteMap[cardId];
      
      // Create a canvas to extract the specific card from the spritesheet
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Spritesheet layout: 7 columns √ó 4 rows, evenly distributed
      // We'll calculate exact dimensions when the image loads
      const COLS = 7;
      const ROWS = 4;
      
      // Load the spritesheet
      const img = new Image();
      img.onload = function() {
        // Calculate card dimensions based on actual image size
        const CARD_WIDTH = img.width / COLS;
        const CARD_HEIGHT = img.height / ROWS;
        
        // Set canvas to card size
        canvas.width = CARD_WIDTH;
        canvas.height = CARD_HEIGHT;
        
        // Calculate position in spritesheet
        const sx = sprite.col * CARD_WIDTH;
        const sy = sprite.row * CARD_HEIGHT;
        
        // Draw the specific card onto the canvas
        ctx.drawImage(
          img,
          sx, sy, CARD_WIDTH, CARD_HEIGHT,  // Source rectangle from spritesheet
          0, 0, CARD_WIDTH, CARD_HEIGHT      // Destination rectangle on canvas
        );
        
        // Convert canvas to data URL and display
        cardPreviewImage.src = canvas.toDataURL();
        cardPreviewName.textContent = cardName;
        cardPreviewModal.classList.add('visible');
      };
      
      img.src = '/images/tussie_mussie.png';
    }
    
    function hideCardPreview() {
      cardPreviewModal.classList.remove('visible');
    }
    
    // Close modal on button click
    cardPreviewClose.addEventListener('click', hideCardPreview);
    
    // Close modal on background click
    cardPreviewModal.addEventListener('click', (e) => {
      if (e.target === cardPreviewModal) {
        hideCardPreview();
      }
    });
    
    // Handle long press on cards
    function setupCardLongPress(cardElement, cardId, cardName) {
      if (!cardId || cardId === 'back') return; // Don't set up for card backs
      
      cardElement.classList.add('can-preview');
      
      // Touch events for mobile
      cardElement.addEventListener('touchstart', (e) => {
        longPressTriggered = false;
        longPressTarget = cardElement;
        
        // Temporarily disable text selection on this element
        cardElement.style.webkitUserSelect = 'none';
        cardElement.style.userSelect = 'none';
        
        longPressTimer = setTimeout(() => {
          longPressTriggered = true;
          showCardPreview(cardId, cardName);
        }, 500); // 500ms long press
      }, { passive: false });
      
      cardElement.addEventListener('touchend', (e) => {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        
        // Re-enable text selection
        cardElement.style.webkitUserSelect = '';
        cardElement.style.userSelect = '';
        
        // If long press was triggered, prevent the click/tap from propagating
        if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
        }
        
        longPressTarget = null;
      });
      
      cardElement.addEventListener('touchmove', () => {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        // Re-enable text selection since user is moving
        cardElement.style.webkitUserSelect = '';
        cardElement.style.userSelect = '';
        longPressTriggered = false;
      });
      
      // Mouse events for desktop
      cardElement.addEventListener('mousedown', (e) => {
        // Right click shows preview immediately
        if (e.button === 2) {
          e.preventDefault();
          longPressTriggered = true;
          showCardPreview(cardId, cardName);
          return;
        }
        
        longPressTriggered = false;
        longPressTarget = cardElement;
        longPressTimer = setTimeout(() => {
          longPressTriggered = true;
          showCardPreview(cardId, cardName);
        }, 500); // 500ms long press
      });
      
      cardElement.addEventListener('mouseup', () => {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        longPressTarget = null;
      });
      
      cardElement.addEventListener('mouseleave', () => {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        longPressTriggered = false;
        longPressTarget = null;
      });
      
      // Prevent the click event if long press was triggered
      cardElement.addEventListener('click', (e) => {
        if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          longPressTriggered = false;
        }
      }, true); // Use capture phase to catch it early
      
      // Prevent context menu on right click
      cardElement.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
    }
  </script>
</body>
</html>